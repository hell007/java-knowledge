
## java-Lock类


之前已经说道，JVM提供了synchronized关键字来实现对变量的同步访问以及用wait和notify来实现线程间通信。

在jdk1.5以后，JAVA提供了Lock类来实现和synchronized一样的功能，并且还提供了Condition来显示线程间通信。 

Lock类是Java类来提供的功能，丰富的api使得Lock类的同步功能比synchronized的同步更强大。

```

1. Lock类
2. Lock类其他功能
3. Condition类
4. Condition类其他功能
5. 读写锁

```

## Lock类

Lock类实际上是一个接口，我们在实例化的时候实际上是实例化实现了该接口的类

```
Lock lock = new ReentrantLock();

```

用synchronized的时候，synchronized可以修饰方法，或者对一段代码块进行同步处理。 
前面讲过，针对需要同步处理的代码设置对象监视器，比整个方法用synchronized修饰要好。
Lock类的用法也是这样，通过Lock对象lock，用lock.lock来加锁，用lock.unlock来释放锁。在两者中间放置需要同步处理的代码。

具体的例子如下：

```
public class MyConditionService {

    private Lock lock = new ReentrantLock();
    
    public void testMethod(){
        lock.lock();
        for (int i = 0 ;i < 5;i++){
            System.out.println("ThreadName = " + Thread.currentThread().getName() + (" " + (i + 1)));
        }
        lock.unlock();
    }
}
```

测试的代码如下：

```
MyConditionService service = new MyConditionService();
new Thread(service::testMethod).start();
new Thread(service::testMethod).start();

Thread.sleep(1000 * 5);

```

结果就是每个线程的打印1-5都是同步进行，顺序没有乱。

通过下面的例子，可以看出Lock对象加锁的时候也是一个对象锁，持续对象监视器的线程才能执行同步代码，其他线程只能等待该线程释放对象监视器。


```
public class MyConditionMoreService {

    private Lock lock = new ReentrantLock();
    
    public void methodA(){
        try{
            lock.lock();
            System.out.println("methodA begin ThreadName=" + Thread.currentThread().getName() +
                    " time=" + System.currentTimeMillis());
            Thread.sleep(1000 * 5);

            System.out.println("methodA end ThreadName=" + Thread.currentThread().getName() +
                    " time=" + System.currentTimeMillis());
        }catch (Exception e){
            e.printStackTrace();
        }finally {
            lock.unlock();
        }
    }

    public void methodB(){
        try{
            lock.lock();
            System.out.println("methodB begin ThreadName=" + Thread.currentThread().getName() +
                    " time=" + System.currentTimeMillis());
            Thread.sleep(1000 * 5);

            System.out.println("methodB end ThreadName=" + Thread.currentThread().getName() +
                    " time=" + System.currentTimeMillis());
        }catch (Exception e){
            e.printStackTrace();
        }finally {
            lock.unlock();
        }
    }
}

```

测试代码如下：

```
public class ThreadA extends Thread{

    private MyConditionMoreService service;

    public ThreadA(MyConditionMoreService service){
        this.service = service;
    }

    @Override
    public void run() {
        service.methodA();
    }
}

public class ThreadB extends Thread{

    private MyConditionMoreService service;

    public ThreadB(MyConditionMoreService service){
        this.service = service;
    }

    @Override
    public void run() {
        super.run();
        service.methodB();
    }
}

public void testMethod() throws Exception {

      MyConditionMoreService service = new MyConditionMoreService();
      
      ThreadA a = new ThreadA(service);
      a.setName("A");
      a.start();

      ThreadA aa = new ThreadA(service);
      aa.setName("AA");
      aa.start();

      ThreadB b = new ThreadB(service);
      b.setName("B");
      b.start();

      ThreadB bb = new ThreadB(service);
      bb.setName("BB");
      bb.start();

      Thread.sleep(1000 * 30);
}
    
```

结果如下：

```

methodA begin ThreadName=A time=1485590913520
methodA end ThreadName=A time=1485590918522
methodA begin ThreadName=AA time=1485590918522
methodA end ThreadName=AA time=1485590923525
methodB begin ThreadName=B time=1485590923525
methodB end ThreadName=B time=1485590928528
methodB begin ThreadName=BB time=1485590928529
methodB end ThreadName=BB time=1485590933533

```

可以看出 **Lock类加锁确实是对象锁**。针对同一个lock对象执行的lock.lock是获得对象监视器的线程才能执行同步代码 其他线程都要等待。 

在这个例子中，加锁，和释放锁都是在try-finally。这样的好处是在任何异常发生的情况下，都能保障锁的释放。


## Lock类其他的功能

如果Lock类只有lock和unlock方法也太简单了，Lock类提供了丰富的加锁的方法和对加锁的情况判断。主要有

```
实现锁的公平
获取当前线程调用lock的次数，也就是获取当前线程锁定的个数
获取等待锁的线程数
查询指定的线程是否等待获取此锁定
查询是否有线程等待获取此锁定
查询当前线程是否持有锁定
判断一个锁是不是被线程持有
加锁时如果中断则不加锁，进入异常处理
尝试加锁，如果该锁未被其他线程持有的情况下成功

```














