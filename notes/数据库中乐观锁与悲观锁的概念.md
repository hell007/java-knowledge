
## 数据库中乐观锁与悲观锁的概念

锁（ locking ）

业务逻辑的实现过程中，往往需要保证数据访问的排他性。如在金融系统的日终结算

处理中，我们希望针对某个 cut-off 时间点的数据进行处理，而不希望在结算进行过程中

（可能是几秒种，也可能是几个小时），数据再发生变化。此时，我们就需要通过一些机

制来保证这些数据在某个操作过程中不会被外界修改，这样的机制，在这里，也就是所谓

的 “ 锁 ” ，即给我们选定的目标数据上锁，使其无法被其他程序修改。

Hibernate 支持两种锁机制：即通常所说的 “ 悲观锁（ Pessimistic Locking ） ”

和 “ 乐观锁（ Optimistic Locking ） ” 。

悲观锁（ Pessimistic Locking ）

悲观锁，正如其名，它指的是对数据被外界（包括本系统当前的其他事务，以及来自

外部系统的事务处理）修改持保守态度，因此，在整个数据处理过程中，将数据处于锁定

状态。悲观锁的实现，往往依靠数据库提供的锁机制（也只有数据库层提供的锁机制才能

真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系

统不会修改数据）。

一个典型的倚赖数据库的悲观锁调用：

select * from account where name=”Erica” for update

这条 sql 语句锁定了 account 表中所有符合检索条件（ name=”Erica” ）的记录。

本次事务提交之前（事务提交时会释放事务过程中的锁），外界无法修改这些记录。

Hibernate 的悲观锁，也是基于数据库的锁机制实现。

注意，只有在查询开始之前（也就是 Hiberate 生成 SQL 之前）设定加锁，才会

真正通过数据库的锁机制进行加锁处理，否则，数据已经通过不包含 for update

子句的 Select SQL 加载进来，所谓数据库加锁也就无从谈起。

乐观锁（ Optimistic Locking ）

相对悲观锁而言，乐观锁机制采取了更加宽松的加锁机制。悲观锁大多数情况下依

靠数据库的锁机制实现，以保证操作最大程度的独占性。但随之而来的就是数据库

性能的大量开销，特别是对长事务而言，这样的开销往往无法承受。

如一个金融系统，当某个操作员读取用户的数据，并在读出的用户数据的基础上进

行修改时（如更改用户帐户余额），如果采用悲观锁机制，也就意味着整个操作过

程中（从操作员读出数据、开始修改直至提交修改结果的全过程，甚至还包括操作

员中途去煮咖啡的时间），数据库记录始终处于加锁状态，可以想见，如果面对几

百上千个并发，这样的情况将导致怎样的后果。

乐观锁机制在一定程度上解决了这个问题。乐观锁，大多是基于数据版本

（ Version ）记录机制实现。何谓数据版本？即为数据增加一个版本标识，在基于

数据库表的版本解决方案中，一般是通过为数据库表增加一个 “version” 字段来

实现。

读取出数据时，将此版本号一同读出，之后更新时，对此版本号加一。此时，将提

交数据的版本数据与数据库表对应记录的当前版本信息进行比对，如果提交的数据

版本号大于数据库表当前版本号，则予以更新，否则认为是过期数据。

对于上面修改用户帐户信息的例子而言，假设数据库中帐户信息表中有一个

version 字段，当前值为 1 ；而当前帐户余额字段（ balance ）为 $100 。

1 操作员 A 此时将其读出（ version=1 ），并从其帐户余额中扣除 $50

（ $100-$50 ）。

2 在操作员 A 操作的过程中，操作员 B 也读入此用户信息（ version=1 ），并

从其帐户余额中扣除 $20 （ $100-$20 ）。

3 操作员 A 完成了修改工作，将数据版本号加一（ version=2 ），连同帐户扣

除后余额（ balance=$50 ），提交至数据库更新，此时由于提交数据版本大

于数据库记录当前版本，数据被更新，数据库记录 version 更新为 2 。

4 操作员 B 完成了操作，也将版本号加一（ version=2 ）试图向数据库提交数

据（ balance=$80 ），但此时比对数据库记录版本时发现，操作员 B 提交的

数据版本号为 2 ，数据库记录当前版本也为 2 ，不满足 “ 提交版本必须大于记

录当前版本才能执行更新 “ 的乐观锁策略，因此，操作员 B 的提交被驳回。

这样，就避免了操作员 B 用基于 version=1 的旧数据修改的结果覆盖操作

员 A 的操作结果的可能。

从上面的例子可以看出，乐观锁机制避免了长事务中的数据库加锁开销（操作员 A

和操作员 B 操作过程中，都没有对数据库数据加锁），大大提升了大并发量下的系

统整体性能表现。

需要注意的是，乐观锁机制往往基于系统中的数据存储逻辑，因此也具备一定的局

限性，如在上例中，由于乐观锁机制是在我们的系统中实现，来自外部系统的用户

余额更新操作不受我们系统的控制，因此可能会造成脏数据被更新到数据库中。在

系统设计阶段，我们应该充分考虑到这些情况出现的可能性，并进行相应调整（如

将乐观锁策略在数据库存储过程中实现，对外只开放基于此存储过程的数据更新途

径，而不是将数据库表直接对外公开）。

[文章来源](https://blog.csdn.net/phphot/article/details/2630620)

